#!/usr/bin/env sh
set -u
LC_ALL=C
export LC_ALL
umask 022

archive=:
case $0 in
*tag)
	archive=false;;
esac

Echo() {
	printf '%s\n' "$*"
}

Echon() {
	printf '%s' "$*"
}

EchoExec() {
	Echo "# $*"
	"$@"
}

Fatal() {
	Echo "${0##*/}: $1" >&2
	exit 1
}

Usage() {
	if $archive
	then	help='
Create (and optionally sign) a tarball for a release, and sign
all other tarballs in the directory.

The format of the tarball corresponds to that from github,
so that you can use the signature file for the release without
downloading that tarball first: This way, the problem is avoided
that unsigned data is transferred over the net before signing.

Note that to get byte-identical zip files (as necessary for signing),
the timezone of the generating servers must be identical.
The script sets the timezone to PST8PDT (of the github servers) by default,
but you can override this by some options.
'
		extraopts='
-p     Set TZ to ":/usr/share/zoneinfo/US/Pacific-New" for zip file generation
-P VAL Set TZ to VAL. If VAL is empty or "-", do not modify TZ'
	else	help='
Tag a release (reminding about possible signing) or remove a tag.'
		extraopts='
-d     Delete tag (locally)
-D     Delete tag (locally and remotely)
-r     Remove tag (remotely)'
	fi
	Echo "Usage: ${0##*/} [options] [tag]$help
-s     Sign$signdefault
-a     Do not sign$unsigndefault
-t     Set GPG_TTY to current tty when signing (default)
-T     Do not modify GPG_TTY$extraopts
-f     Force even if tag does not start with v
-h     Show this help"
	exit ${1:-1}
}

if [ -n "${GPG_TTY++}" ]
then	sign=:
	signdefault=' (default since $GPG_TTY is set)'
	unsigndefault=
else	sign=false
	signdefault=
	unsigndefault=' (default since $GPG_TTY is unset)'
fi

if $archive
then	addopt=pP:
else	addopt=dDr
fi

tz=PST8PDT
gettty=:
force=false
delete=false
remove=false
OPTIND=1
while getopts "ftTsahH$addopt" opt
do	case $opt in
	s)	sign=:;;
	a)	sign=false;;
	p)	tz=:/usr/share/zoneinfo/US/Pacific-New;;
	P)	tz=$OPTARG;;
	d)	delete=:;;
	D)	delete=:
		remove=:;;
	r)	remove=:;;
	t)	gettty=:;;
	T)	gettty=false;;
	f)	force=:;;
	'?')	exit 1;;
	*)	Usage 0;;
	esac
done
shift $(( $OPTIND - 1 ))

test -d .git || Fatal '.git does not exit'

if $sign
then	tagtext=signed
else	tagtext=unsigned
fi

if [ $# -gt 0 ]
then	tag=$1
else	EchoExec git tag -ln
	latesttag=`git describe --abbrev=0 2>/dev/null` || latesttag=
	if [ -z "${latesttag:++}" ]
	then	Echo 'Latest tag cannot be determined'
	else	Echo "$latesttag		(latest tag)"
	fi
	if $archive
	then	Echon "Enter tag for $tagtext tarball (default: $latesttag): "
	elif $delete || $remove
	then	if $delete
		then	if $remove
			then	remtext='remove locally+remotely'
			else	remtext='delete locally'
			fi
		else	remtext='remove remotely'
		fi
		Echon "Enter tag to $remtext (default: $latesttag): "
	else	Echon "Enter new tag for $tagtext commit: "
	fi
	read -r tag
	if $archive || $delete || $remove
	then	[ -n "${tag:++}" ] || tag=$latesttag
	fi
fi

case ${tag:-/} in
*[!.0123456789abcdefghijklmnopqrstuvwxyz]*)
	Fatal 'Illegal tag';;
esac
! $force && case $tag in
v*)
	false;;
esac && Fatal 'tag must start with v'

if $delete || $remove
then	! $delete || EchoExec git tag -d "$tag"
	! $remove || EchoExec git push origin ":refs/tags/$tag"
	exit
fi

if $sign && $gettty
then	GPG_TTY=`tty` && [ -n "${GPG_TTY:++}" ] && export GPG_TTY \
		|| unset GPG_TTY
fi

if ! $archive
then	if $sign
	then	tagopt=-s
	else	tagopt=-a
	fi
	git tag $tagopt "$tag" -m "Release $tag" || exit
	Echo "Tagged successfully $tag release ($tagtext)"
	exit
fi

name=${PWD##*/}
name=${name%.git}
n=$name-${tag#v}
EchoExec git archive --prefix="$n/" -o "$n.tar.gz" "$tag"
(
	[ "${tz:--}" = '-' ] || {
		TZ=$tz
		export TZ
		Echo "# export TZ=\"$tz\""
	}
	EchoExec git archive --prefix="$n/" -o "$n.zip" "$tag"
)
$sign || exit 0

for i in *.tar *.tar.* *.zip
do	case $i in
	*.asc)
		continue;;
	esac
	test -f "$i" || continue
	EchoExec gpg --armor --detach-sign "$i"
done
:
